# PSSG Readme

## Explanation of old repo layout and translation:
The repohyper repo, along side included instructions, can be summarized as follows:
* download the repobench dataset (the current branch doesn't work, use commit 4e4c4c837f81b24da5929c6b09908d35ea59d3dc)
* Generate call graphs. They did this using pycg, a deprecated tool, and its hard to find an equivalent for CUDA. Our options are to compile the CUDA code and run the llvm opt tool, compile and use the cuda NVLINK (not the phyiscal connector), or use [this github repo](https://github.com/Vermeille/clang-callgraph/tree/master) (clang oriented but because clang 3.8+ supports cuda (but does lag a few versions behind) we can configure the script using the compile_commands.json to support cuda). I think the script is a better option because the other two options are llvm/assembler callgraphs and may suffer from optimization and are a bit more difficult to parse because of all the junk they contain. See this [SO post](https://stackoverflow.com/questions/11423266/call-graphs-for-cuda)
* **THIS STEP NEEDS THE MOST WORK**  Generate "embeddings for each node" -- this step is where tree sitter is invoked. Essentially this uses the call graph to validate the tree sitter parsing of functions, classes etc, and then generates a more comiplcated graph structure and embeds it with either t5 or Unixcoder. 
   * Source code comment often refers to ``` # checking whether function is in the call graph and add call graph edges if there's any; # checking whether file is in the graph nodes and add call graph edges if there's any; ``` It also appears that in the function `parse_source` the returned `context_files` object does have a relative path for each file, so maybe that is enough context for directory structure? we'll see.   `load_contexts_then_embed`: find this file in the source code (repo_to_graph.py), it has a doc string that very nicely summarizes the structure of the output of `parse_source` and how the embedding is done and complicated graph is constructed.